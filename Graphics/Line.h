#pragma once
#include <graphics.h>
#include <iostream>
#include "Brush.h"
using namespace std;
class Line : public Brush
{
	
private:
	int x_s, y_s, x_e, y_e, x, y;
	int width;

public:
	Line(int XS, int YS, int XE, int YE, int W, COLORREF C):Brush(W,C) {
		x_s = XS;
		x_e = XE;
		y_s = YS;
		y_e = YE;
		width = W;
		x = XS;
		y = YS;

	}
	void Bresenham() {
		int dx = abs(x_e - x_s), sx = x_s < x_e ? 1 : -1;
		int dy = abs(y_e - y_s), sy = y_s < y_e ? 1 : -1;
		int err = (dx < dy ? dx : -dy) / 2, e2;
		while (true)
		{

			drawPixle(x ,y);

			if (x == x_e) break;
			e2 = err;
			if (e2 > -dx) {
				err -= dy;
				x += sx;
			}
			if (e2 < dy) {
				err += dx;
				y += sy;
			}

			//cout << "(" << x << " , " << y << "),k= " << k << " ,b= " << b << " color= " << color << endl;

		}
	}
	void MidPoint() {
		//TODO:帮我补上
	}
	void Midpointline()
	{
		int a, b, d1, d2, x, y,d;
		a = y_s - y_e; 
		b = x_e - x_s;  
		d = a + a + b;  //计算a,b,d0
		d1 = a + a;  
		d2 = a + a + b + b;            //计算可能的增量
		x = x_s; 
		y = y_s;
		drawPixle(x, y);
		while (x != x_e&&y!=y_e)
		{

			if (d < 0)
			{
				x++;
				y++;
				d += d2;
			}  //如果d为负，取右上角点(y加1)
			else {
				x++;
				d += d1;
			}          //如果d为正，取右边点
			
			
			drawPixle(x, y);
		}
	}
	
};

void Lines() {
	ExMessage m;		//获取鼠标操作对象
	int X1, Y1;
	while (true) {
		m = getmessage(EM_MOUSE | EM_KEY);
		switch (m.message)
		{
		case WM_LBUTTONDOWN:	//按下鼠标左键
			// 记住起点
			X1 = m.x;
			Y1 = m.y;
			cout << "start:(" << m.x << " , " << m.y << ")" << endl;
			break;

		case WM_LBUTTONUP:		//抬起鼠标左键
			if ((m.x - X1) * (m.x - X1) + (m.y - Y1) * (m.y - Y1) < 10)
			{
				cout << "Too short!" << endl;
				break;
			}
			cout << "end:(" << m.x << " , " << m.y << ")" << endl;
			Line l(X1, Y1, m.x, m.y, 9, WHITE);
			//l.drawPixle(m.x, m.y);
			l.Bresenham();
			// 鼠标左键弹起,记住终点并画线
			break;
		}
		if (m.vkcode == VK_NUMPAD0) return;
	}
}